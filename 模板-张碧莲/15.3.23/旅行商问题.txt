一个人从p1严格地增的走到pn，然后再严格递减的回到p1;求总路径的最小值；  
double p[N][N]; //p[i][j]表示结点i到结点j之间的距离
double dp[N][N]; //dp[i][j]表示从i连到1，再从1连到j，（注意，i>j，且并没有相连.）
dp[0][0]=0;
for(i=1;i<n-1;i++)
{
	dp[i][0]=0;
	for(int k=i;k>0;k--) dp[i][0]+=p[k][k-1];
	dp[i+1][i]=MAX;
	for(j=0;j<i;j++)
	{
		dp[i+1][j]=dp[i][j]+p[i][i+1];
		dp[i+1][i]=Min(dp[i+1][i],dp[i][j]+p[j][i+1]);
	}
}