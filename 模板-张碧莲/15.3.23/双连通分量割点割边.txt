#include"stdafx.h"
#pragma comment(linker, "/STACK:1024000000,1024000000") 
#include<iostream> 
#include<cstring> 
#include<stdio.h> 
#include<cmath>  
#include<algorithm> 
#include<sstream> 
#include<map> 
#include<set> 
#include<queue>
#include<vector> 
#include<stack> 
#include<iomanip> 
#include<string.h>
#include<bitset>
#include<deque>
using namespace std;

const int N = 1005;
const int M = N*N;
vector<int>e[N];

int top,bcc,id,dfn[N],low[N],belong[N],sub[N],val[N][N],ans,num[N][N];

bool in[N],cut_p[N],cut_e[M];

int ltcnt;//连通块数量
stack<int> S;

void init()
{
    top = 0;
    for(int i=0;i<N;i++) e[i].clear();
	fill(&val[0][0],&val[N-1][N-1]+1,INT_MAX);
	fill(&num[0][0],&num[N-1][N-1]+1,0);
}

void add_edge(int u,int v)
{
	e[u].push_back(v);
	e[v].push_back(u);
}

void tarjan(int pre,int u)
{
    dfn[u] = low[u] = ++id;
    int cnt = 0;
    S.push(u);
    for(int i=0;i<e[u].size();i++)
    {
        int v = e[u][i];
        if(v == pre)
            continue;
        if(!dfn[v])
        {
			ltcnt++;
            ++cnt;
            tarjan(u,v);
            low[u] = min(low[u],low[v]);
            if(u!=pre && dfn[u]<=low[v])
            {
                cut_p[u] = true;
                sub[u]++;
            }
            if(dfn[u] < low[v])
			{
              //  cut_e[i] = true;
				if(num[u][v]==1)ans=min(ans,val[u][v]);
			}
        }
        else
            low[u] = min(low[u],dfn[v]);
    }
    if(dfn[u] == low[u])
    {
        int v;
        do
        {
            v = S.top();
            S.pop();
            belong[v] = bcc;
        }while(u != v);
        bcc++;
    }
    if(u==pre && cnt>1)
    {
        cut_p[u] = true;
        sub[u] = cnt-1;
    }
}

void get_bcc_cutp_cute(int n)
{
	ltcnt=0;
    bcc = id = 0;
    memset(cut_p,false,sizeof(cut_p));
    memset(cut_e,false,sizeof(cut_e));
    memset(dfn,0,sizeof(dfn));
    memset(sub,0,sizeof(sub));
    for(int i=0;i<n;i++)
        if(!dfn[i])
            tarjan(-1,i);
}


int main()
{
	int n,m;
    while(~scanf("%d%d",&n,&m)) 
    {
		init();
		if(n==0 && m==0) break;
		for(int i=0;i<m;i++)
		{
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			a--,b--;
			num[a][b]++,num[b][a]++;
			add_edge(a,b);
			val[a][b]=min(val[a][b],c);
			val[b][a]=min(val[b][a],c);
		}
		ans=INT_MAX;
		get_bcc_cutp_cute(n);
		if(ltcnt<n-1) printf("0\n");
		else
		{
			if(ans==0) ans=1;
			printf("%d\n",ans==INT_MAX?-1:ans);
		}
    }

    return 0;
}