 //  low(u) = Min{visited[u], low[v], visited[w] }

#include<iostream>
using namespace std;

const int N=55;
int step,son,sumedge,mat[N][N],dfn[N],low[N],n; 
bool CutPoint[N],CutEdge[N][N];

int Min(int a, int b)
{
	if(a>b) return b;
	return a;
}
// 从顶点u出发深度优先遍历图, 查找并记录关节点
void  DFSArticul(int u, int fa, int root)
{ // fa是u的父节点    
	int v;
	low[u] = dfn[u] = ++step;              
	for(v=0; v<n; v++) if(mat[u][v]==1)
	{ // 检查u的每个邻接点v
		if(v==fa) continue;   // 跳过父节点	
		if(dfn[v]==0)
		{ // v未曾被访问
			if(u==root) son++;		// 子树数量加1 
			DFSArticul(v,u,root);
			low[u] = Min(low[u],low[v]);
			if (low[v]>=dfn[u] && u!=root) CutPoint[u]=true; //记录关节点
			if(low[v] > dfn[u])  
			{
				if(CutEdge[v][u]==false) sumedge++;
				CutEdge[v][u]=true;
				CutEdge[u][v]=true;
			}
		}
		else low[u]=Min (low[u],dfn[v]); // (u,v)是回边back edge
	}
}

void run()
{
	int i;
	fill(&mat[0][0],&mat[n][n]+1,0);
	while(true)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(a==0 && b==0) break;
		a--;
		b--;
		mat[a][b]=1;
		mat[b][a]=1;
	}
	int sumpoint=0;
	sumedge=0;
	fill(&CutEdge[0][0],&CutEdge[N-1][N-1]+1,false);
	for(i=0;i<n;i++)
	{
		step=0; 
		son=0; 
		fill(dfn,dfn+N,0); 
		fill(CutPoint, CutPoint+N,false);
		DFSArticul(i,-1,i); 
		if (son >=2) 
		{
			CutPoint[i]=true; 
			sumpoint++;
		}
	}
	cout<<sumpoint<<' '<<sumedge<<endl;
	
}

int main()
{
	while(scanf("%d",&n)!=EOF)
	{
		run();
	}
	return 0;
}