void HeapAdjust (vector<message>&R, int s, int m)
{
    message rc = R[s];    // 暂存 R[s]
    //自上而下的筛选过程;
    for (int j=2*s; j<=m; j*=2 )
    { 
        // 左右子树“根”之间先相互比较, 令 j 指示较大记录
        if ( j<m && big(R[j],R[j+1]))  j++;    
        // “根”和大“子树根”之间比较
        if ( rc.first < R[j].first  || (rc.first == R[j].first && rc.no<=R[j].no))  break; 
        // 大关键字记录往上调，子树尚需继续调整
        R[s] = R[j];   s = j;              
    }
    R[s] = rc;  // 将调整前的堆顶记录插入到 s 位置
} // HeapAdjust

void HeapSort (vector<message>&R, int len ) 
{ // 对R[]进行堆排序
    int i;
    for ( i=len/2;   i>0;   i-- )
        HeapAdjust ( R, i, len );    // 建大顶堆
    //    for(i=1;i<=len;i++) cout<<R[i].name<<' '<<R[i].rp<<endl;
    for ( i=len; i>1; i-- ) 
    {
        // 将堆顶记录和当前未排序的子序列R[1..i]中
        // 最后一个记录R[i]交换， 此时R[i, len]有序
        //    swap(R[1],  R[i]); 
        message t=R[1];
        R[1]=R[i];
        R[i]=t;
        //        for(int j=1;j<=len;j++) cout<<R[j].name<<' '<<R[j].rp<<endl;
        HeapAdjust(R, 1, i-1);  //将 R[1..i-1] 重新调整为大顶堆
    }
    // 最后R[1..len]有序
} // HeapSort
