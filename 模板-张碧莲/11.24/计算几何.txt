
const double pi=4.0*atan(1.0);
const int N=10005;

struct Point
{
	double x,y;
	Point(double x=0,double y=0):x(x),y(y){}
};
typedef Point Vector;
Vector operator + (Vector A, Vector B){ return Vector(A.x+B.x, A.y+B.y);}
Vector operator - (Vector A, Vector B){ return Vector(A.x-B.x, A.y-B.y);}
Vector operator * (Vector A, double p){ return Vector(A.x*p, A.y*p);}
Vector operator / (Vector A, double p){ return Vector(A.x/p, A.y/p);}
bool operator < (const Point &a,const Point &b)
{
	return a.x<b.x || (a.x == b.x && a.y < b.y);
}
const double eps = 1e-10;
int dcmp(double x) { if(fabs(x) < eps) return 0; else return x<0?-1:1;}
bool operator == (const Point &a, const Point &b){ return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0;}
double Dot(Vector A,Vector B){ return A.x*B.x+A.y*B.y;}//点积
double Length(Vector A){ return sqrt(Dot(A,A)); }//向量长度
double Angle(Vector A,Vector B){ return acos(Dot(A,B)/Length(A)/Length(B)); }//向量夹角
double Cross(Vector A,Vector B){ return A.x*B.y-A.y*B.x; }//叉积
double Area2(Point A,Point B,Point C){ return Cross(B-A,C-A); }//多边形有向面积的两倍
Vector Rotate(Vector A,double rad){ return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad)); }//向量旋转rad为弧度
Vector Normal(Vector A){ double L=Length(A); return Vector(-A.y/L,A.x/L);}//计算向量的单位法线，调用前确保A不是零向量

//返回直线交点，调用前确保Cross(v,w)!=0
Point GetLineIntersection(Point P,Vector v,Point Q,Vector w)
{
	Vector u=P-Q;
	double t=Cross(w,u)/Cross(v,w);
	return P+v*t;
}

//点到直线距离
double DistanceToLine(Point P,Point A,Point B)
{
	Vector v1=B-A,v2=P-A;
	return fabs(Cross (v1,v2))/Length(v1);
}

//点到线段的距离
double DistanceToSegment(Point P,Point A,Point B)
{
	if(A==B) return Length(P-A);
	Vector v1=B-A,v2=P-A,v3=P-B;
	if(dcmp(Dot(v1,v2))<0) return Length(v2);
	else if(dcmp(Dot(v1,v3))>0) return Length(v3);
	else return fabs(Cross(v1,v2))/Length(v1);
}

//点在直线上的投影
Point GetLineProjection(Point P,Point A,Point B)
{
	Vector v=B-A;
	return A+v*(Dot(v,P-A)/Dot(v,v));
}

//线段相交判定(不含端点)
bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2)
{
	double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1),
		c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1);
	return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;
}

//判断点是否在一条线段上（不包含端点）
bool OnSegment(Point p, Point a1,Point a2)
{
	return dcmp(Cross(a1-p,a2-p))==0 && dcmp(Dot(a1-p,a2-p))<0;
}

//线段相交（包含端点）
bool intersect(Point a, Point b ,Point c,Point d)
{
	if(SegmentProperIntersection(a,b,c,d)) return true;
	if(a==c && b==d==false) return true;
	if(b==d && a==c==false) return true;
	if(OnSegment(a,c,d)) return true;
	if(OnSegment(b,c,d)) return true;
	if(OnSegment(c,a,b)) return true;
	if(OnSegment(d,a,b)) return true;
	return false;
}

//计算多边形面积
double PolygonArea(Point *p,int n)
{
	double area=0;
	for(int i=1;i<n-1;i++)
		area += Cross(p[i]-p[0],p[i+1]-p[0]);
	return area/2;
}
double PolygonArea(vector<Point> p,int n)
{
	double area=0;
	for(int i=1;i<n-1;i++)
		area += Cross(p[i]-p[0],p[i+1]-p[0]);
	return area/2;
}

//判断点是否在多边形内
int isPointInPolypon(Point p, Point* poly,int n)
{
	int wn=0;
	for(int i=0;i<n;i++)
	{
		if(OnSegment(p,poly[i],poly[(i+1)%n]) || p==poly[i] || p==poly[(i+1)%n]) return 1;
		int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));
		int d1=dcmp(poly[i].y-p.y);
		int d2=dcmp(poly[(i+1)%n].y-p.y);
		if(k>0 && d1<=0 && d2>0) wn++;
		if(k<0 && d2<=0 && d1>0) wn--;
	}
	if(wn!=0) return 1;
	return 0;
}

bool cmp(Point a,Point b)
{
	return a.x<b.x || (a.x==b.x && a.y<b.y);
}

//输入点数组p,个数为n,输出点数组ch.函数返回凸包顶点数.
//输入不能有重复点。函数执行完之后输入点的顺序被破坏
//如果不希望在凸包的边上有输入点，把两个<=改成<
//在精度要求高时用dcmp比较
int ConvexHull(Point *p,int n,Point *ch)
{
	sort(p,p+n,cmp);
	int m=0;
	for(int i=0;i<n;i++)
	{
		while(m>1 && dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0)) m--;
		ch[m++]=p[i];
	}
	int k=m;
	for(int i=n-2;i>=0;i--)
	{
		while(m>k && dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0)) m--;
		ch[m++]=p[i];
	}
	if(n>1) m--;
	return m;
}

//有向直线
struct Line
{
	Point P;//直线上任意一点
	Vector v;//方向向量
	double ang;//极角
	Line(){}
	Line(Point P,Vector v):P(P),v(v){ang=atan2(v.y,v.x);}
	bool operator<(const Line &L)const{ return ang<L.ang;}
};

//点p在有向直线L的左边（线上不算）
bool OnLeft(Line L,Point p){ return Cross(L.v,p-L.P)>0;}
//两直线交点 确保交点唯一存在
Point GetIntersection(Line a,Line b)
{
	Vector u=a.P-b.P;
	double t=Cross(b.v,u)/Cross(a.v,b.v);
	return a.P+a.v*t;
}
Point p[N*2];//p[i]为q[i]和q[i+1]的交点
Line q[N*2];

int HalfplaneIntersection(Line *L,int n,Point *poly)
{
	int first,last;	
	q[first=last=0]=L[0];
	for(int i=1;i<n;i++)
	{
		if(dcmp(L[i].ang-L[i-1].ang)==0 && (fabs(L[i].ang-atan2(L[i-1].P.y-L[i].P.y,L[i-1].P.x-L[i].P.x))<eps || fabs(L[i].ang-atan2(L[i].P.y-L[i-1].P.y,L[i].P.x-L[i-1].P.x))<eps || L[i].P==L[i-1].P)) continue;
		while(first<last && !OnLeft(L[i],p[last-1])) last--;
		while(first<last && !OnLeft(L[i],p[first])) first++;
		q[++last]=L[i];
		if(fabs(Cross(q[last].v,q[last-1].v))<eps)//两向量平行且同向，取内侧的一个
		{
			last--;
			if(OnLeft(q[last],L[i].P)) q[last]=L[i];
		}
		if(first<last) p[last-1]=GetIntersection(q[last-1],q[last]);
	}
	while(first<last && !OnLeft(q[first],p[last-1])) last--;//删除无用平面
	if(last-first<=1) 
	{
		return 0;//空集
	}
	p[last]=GetIntersection(q[last],q[first]);//计算首尾两个半平面的交点
	int m=0;
	for(int i=first;i<=last;i++) poly[m++]=p[i];
	return m;
}

struct Circle
{
	Point c;//圆心
	double r;
	Circle(){}
	Circle(Point c,double r):c(c),r(r){}
	Point point(double a)
	{
		return Point(c.x+cos(a)*r,c.y+sin(a)*r);
	}
};

int getLineCircleIntersection(Point p1,Point p2,Circle C,Point &jd1,Point &jd2)
{
	int cnt=0;
	Vector v=p2-p1;
	double a=(p2-p1).x,b=p2.x-C.c.x,c=(p2-p1).y,d=p2.y-C.c.y;
	double e=a*a+c*c,f=2*(a*b+c*d),g=b*b+d*d-C.r*C.r;
	double delta=f*f-4*e*g;
	if(dcmp(delta)<=0) return 0;
	double t1=(-f-sqrt(delta))/(2*e);
	double x1=a*t1+b+C.c.x,y1=c*t1+d+C.c.y;
	Point t(x1,y1);
	if((dcmp(x1-p1.x)<=0 && dcmp(p2.x-x1)<=0) || (dcmp(x1-p2.x)<=0 && dcmp(p1.x-x1)<=0))
		if((dcmp(y1-p1.y)<=0 && dcmp(p2.y-y1)<=0) || (dcmp(y1-p2.y)<=0 && dcmp(p1.y-y1)<=0))
			{
				jd1=t;
				cnt++;
			}
	double t2=(-f+sqrt(delta))/(2*e);
	x1=a*t2+b+C.c.x,y1=c*t2+d+C.c.y;
	Point tt(x1,y1);
	if((dcmp(x1-p1.x)<=0 && dcmp(p2.x-x1)<=0) || (dcmp(x1-p2.x)<=0 && dcmp(p1.x-x1)<=0))
		if((dcmp(y1-p1.y)<=0 && dcmp(p2.y-y1)<=0) || (dcmp(y1-p2.y)<=0 && dcmp(p1.y-y1)<=0))
			{
				jd2=tt;
				cnt++;
			}
	return cnt;
}

bool cmp2(Point a,Point b)
{
	return atan2(a.y,a.x)>atan2(b.y,b.x);
}

double getareahu(Point p1,Point p2,Circle c)
{
	double A2 = Dot(c.c - p1,c.c - p1), B2 = Dot(c.c - p2,c.c - p2), C2 = Dot(p1 - p2,p1 - p2);
    double w= c.r * c.r * acos((A2 + B2 - C2) * 0.5 / sqrt(A2) / sqrt(B2)) * 0.5;
	return w;
}

double sjhf(Point p1,Point p2,Circle c)
{
	double a=Length(p1-c.c),b=Length(p2-c.c);
	if(a<c.r+eps && b<c.r+eps) return Area2(p1,p2,c.c)/2;
	if(fabs(DistanceToLine(c.c,p1,p2))<eps) return 0.0;
	Point t1,t2;
	int t=getLineCircleIntersection(p1,p2,c,t1,t2);
	if(t==0) return getareahu(p1,p2,c);
	if(a<c.r+eps) return Area2(p1,t2,c.c)/2+getareahu(t2,p2,c);
	if(b<c.r+eps) return Area2(t1,p2,c.c)/2+getareahu(p1,t1,c);
	return Area2(t1,t2,c.c)/2+getareahu(p1,t1,c)+getareahu(t2,p2,c);
}

double getraea(Point *poly,int n,Circle c)
{
	double area=0;
	for(int i=0;i<n;i++)
	{
		double w=dcmp(Cross(poly[i]-c.c,poly[(i+1)%n]-c.c));
		if(w<0) area-=sjhf(poly[(i+1)%n],poly[i],c);
		else area+=sjhf(poly[i],poly[(i+1)%n],c);
	}
	return fabs(area);
}