 #include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;

const int N = 200001;

struct Node
{
	int cover;							// 区间左边的统计值
	int leftKey, rightKey;						// 区间的左右键值
	int left, right;						// 子树编号
};
Node T[2*N];  // 整棵树一共需要的结点总数不超过2*N-1

int tag; // 保存当前实际已经分配的空间

void BuildTree(int root, int l, int r)				// 建立线段树，root为根节点
{
	T[root].leftKey = l;
	T[root].rightKey = r;
	T[root].cover=0;

	if(l == r)
	{
		T[root].left = T[root].right = -1;
		return ;
	}

	tag ++;	// 编号增1,类似于分配新的结点，这里由于事先已经一次性分配了全部的数组元素，所以只需要使用就可以了
	T[root].left = tag;
	BuildTree(tag, l, (l+r)/2);

	tag++;
	T[root].right = tag;
	BuildTree(tag,  (l+r)/2+1, r);	// 注意左右节点的区间：[l,mid],[mid+1,r]
};  

void insert(int root, int p) 						// 单点[p,p]+1 
{
	// 对于任何区间，只要从根节点开始，到达的结点一定是覆盖p的，所以将p的最新值更新
	T[root].cover++;  

	if(p <= T[root].leftKey && T[root].rightKey <= p) return; 		// 叶节点

	int mid = (T[root].leftKey + T[root].rightKey) / 2;	 
	if (p <= mid)								// 去左子树判断
		insert(T[root].left, p);
	else  if(p >= mid+1) 							// 去右子树判断
		insert(T[root].right, p);
}

int query(int root, int l, int r) 						// 区间检索[l,r]的最大值
{
	if(l <= T[root].leftKey && T[root].rightKey <= r) 			// 完全覆盖
	{
		return T[root].cover;
	}
	else 
	{
		int mid = (T[root].leftKey + T[root].rightKey) / 2;	 

		if (r <= mid)							// 去左子树判断
			return query(T[root].left, l, r);
		else if(l >= mid+1) 						// 去右子树判断
			return query(T[root].right, l, r);
		else								// 2部分分别处理
		{
			int k1=query(T[root].left, l, mid);			
			int k2=query(T[root].right, mid+1, r);
			return k1+k2;
		}
	}
}

